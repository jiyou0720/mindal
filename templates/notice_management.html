<!-- frontend/templates/notice_management.html -->
{% extends "base.html" %}

{% block title %}공지사항 관리 - Mindbridge{% endblock %}

{% block head %}
    <link rel="stylesheet" href="{{ url_for('static', filename='css/admin_dashboard.css') }}"> {# 관리자 대시보드 CSS 재사용 #}
    <link rel="stylesheet" href="{{ url_for('static', filename='css/notice_management.css') }}"> {# 공지사항 관리 전용 CSS #}
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
{% endblock %}

{% block content %}
    <div class="admin-dashboard-container">
        <h1>공지사항 관리</h1>
        <p>새로운 공지사항을 작성하고, 기존 공지사항을 수정하거나 공개/비공개 상태를 관리할 수 있습니다.</p>
        <p>현재 로그인된 사용자 역할: <span id="currentUserRolesDisplay"></span></p>

        <div class="admin-section">
            <h2>공지사항 목록</h2>
            <button id="addNoticeButton" class="button primary">새 공지사항 작성</button>
            <div class="notice-list-table-container">
                <table class="notice-list-table">
                    <thead>
                        <tr>
                            <th>ID</th>
                            <th>제목</th>
                            <th>작성자</th>
                            <th>공개 여부</th>
                            <th>작성일</th>
                            <th>수정일</th>
                            <th>게시 시작일</th>
                            <th>게시 종료일</th>
                            <th>액션</th>
                        </tr>
                    </thead>
                    <tbody id="noticeTableBody">
                        <!-- 공지사항 데이터가 여기에 동적으로 로드됩니다 -->
                        <tr><td colspan="9" class="loading-row">공지사항을 불러오는 중...</td></tr>
                    </tbody>
                </table>
            </div>
            <p id="noNoticesMessage" class="no-notices-message hidden">공지사항이 없습니다.</p>
        </div>
    </div>

    <!-- 공지사항 추가/수정 모달 -->
    <div id="noticeModal" class="modal hidden">
        <div class="modal-content">
            <span class="close-button" id="closeModalXButton">&times;</span>
            <h3 id="modalTitle">새 공지사항 작성</h3>
            <form id="noticeForm">
                <input type="hidden" id="noticeId">
                <div class="form-group">
                    <label for="noticeTitle">제목</label>
                    <input type="text" id="noticeTitle" required>
                </div>
                <div class="form-group">
                    <label for="noticeContent">내용</label>
                    <textarea id="noticeContent" rows="10" required></textarea>
                </div>
                {# NEW: 게시 시작일/종료일을 하나의 필드로 통합 #}
                <div class="form-group">
                    <label for="noticePublishDateRange">게시 기간</label>
                    <input type="text" id="noticePublishDateRange" placeholder="클릭하여 기간 선택">
                </div>
                <div class="form-group checkbox-group">
                    <input type="checkbox" id="noticeIsPublic">
                    <label for="noticeIsPublic">공개 상태</label>
                </div>
                <div class="button-group">
                    <button type="submit" class="button primary">저장</button>
                    <button type="button" id="cancelNoticeModalButton" class="button secondary">취소</button>
                </div>
            </form>
        </div>
    </div>
{% endblock %}

{% block scripts %}
    <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
    <script src="https://cdn.jsdelivr.net/npm/flatpickr/dist/l10n/ko.js"></script> {# NEW: 한국어 로케일 파일 추가 #}


    <script>
        // base.html에서 전역으로 선언된 loginUrl, homeUrl, fetchWithAuth, showAlert, showConfirm 사용

        const noticeTableBody = document.getElementById('noticeTableBody');
        const addNoticeButton = document.getElementById('addNoticeButton');
        const noticeModal = document.getElementById('noticeModal');
        const modalTitle = document.getElementById('modalTitle');
        const noticeForm = document.getElementById('noticeForm');
        const cancelNoticeModalButton = document.getElementById('cancelNoticeModalButton');
        const closeModalXButton = document.getElementById('closeModalXButton');
        const noNoticesMessage = document.getElementById('noNoticesMessage');
        const currentUserRolesDisplay = document.getElementById('currentUserRolesDisplay');

        const noticePublishDateRangeInput = document.getElementById('noticePublishDateRange');

        let editingNoticeId = null; // 현재 편집 중인 공지사항 ID
        let datePickerInstance; // Flatpickr 인스턴스를 저장할 변수

        // Flatpickr 초기화 함수 (페이지 로드 시 한 번만 호출)
        function initializeFlatpickr() {
            datePickerInstance = flatpickr(noticePublishDateRangeInput, {
                mode: "range",
                enableTime: true,
                dateFormat: "Y-m-d H:i",
                altInput: true,
                altFormat: "Y년 n월 j일 H시 i분",
                locale: "ko", // 한국어 로케일 설정
                onClose: function(selectedDates, dateStr, instance) {
                    // 사용자가 날짜를 선택했을 때의 로직 (필요시)
                }
            });
        }

        // 관리자/운영자 접근 권한 확인 함수 (이전과 동일)
        async function checkAdminOrOperatorAccess() {
            console.log('checkAdminOrOperatorAccess (notice_management): 함수 시작');
            const token = localStorage.getItem('access_token');
            console.log('checkAdminOrOperatorAccess (notice_management): 로컬 스토리지 access_token:', token ? '존재함' : '없음');

            if (!token) {
                console.log('checkAdminOrOperatorAccess (notice_management): 토큰 없음, 로그인 페이지로 리다이렉트');
                await showAlert('관리자/운영자 페이지에 접근하려면 로그인이 필요합니다.');
                window.location.href = loginUrl;
                return false;
            }

            try {
                console.log('checkAdminOrOperatorAccess (notice_management): /api/auth/me 호출 시도');
                const response = await fetchWithAuth('/api/auth/me', { method: 'GET' });
                console.log('checkAdminOrOperatorAccess (notice_management): /api/auth/me fetchWithAuth 호출 결과:', response);

                if (!response) {
                    console.log('checkAdminOrOperatorAccess (notice_management): fetchWithAuth가 undefined 반환 (401 리다이렉트 발생 예상)');
                    return false;
                }

                if (!response.ok) {
                    console.log('checkAdminOrOperatorAccess (notice_management): /api/auth/me 응답 실패 (response.ok = false), status:', response.status);
                    await showAlert('사용자 역할 정보를 불러오는 데 실패했습니다. 다시 로그인해주세요.');
                    localStorage.removeItem('access_token');
                    window.location.href = loginUrl;
                    return false;
                }

                const data = await response.json();
                const userRoles = data.user.roles || [];
                console.log('checkAdminOrOperatorAccess (notice_management): 사용자 역할:', userRoles);

                // '관리자' 또는 '운영자' 역할이 없으면 접근 제한
                if (!userRoles.includes('관리자') && !userRoles.includes('운영자')) {
                    console.log('checkAdminOrOperatorAccess (notice_management): 관리자 또는 운영자 역할 없음, 홈으로 리다이렉트');
                    await showAlert('관리자 또는 운영자만 접근할 수 있는 페이지입니다.');
                    window.location.href = homeUrl;
                    return false;
                }

                currentUserRolesDisplay.textContent = userRoles.join(', ');
                console.log('checkAdminOrOperatorAccess (notice_management): 접근 권한 확인 완료');
                return true;
            } catch (error) {
                console.error('checkAdminOrOperatorAccess (notice_management): 오류 발생:', error);
                await showAlert('접근 권한 확인 중 오류가 발생했습니다. 다시 시도해주세요.');
                window.location.href = homeUrl;
                return false;
            }
        }

        // 모든 공지사항 불러오기 (이전과 동일)
        async function fetchAllNotices() {
            noticeTableBody.innerHTML = '<tr><td colspan="9" class="loading-row">공지사항을 불러오는 중...</td></tr>';
            noNoticesMessage.classList.add('hidden');

            try {
                const response = await fetchWithAuth('/api/admin/notices');
                if (!response || !response.ok) {
                    const errorData = response ? await response.json() : {};
                    await showAlert(errorData.message || '공지사항 목록을 불러오는 데 실패했습니다.');
                    noticeTableBody.innerHTML = '<tr><td colspan="9" class="error-row">공지사항을 불러오지 못했습니다.</td></tr>';
                    return;
                }
                const data = await response.json();
                renderNoticeTable(data.notices);
            } catch (error) {
                console.error('공지사항 목록 로드 중 오류 발생:', error);
                await showAlert('공지사항 목록을 불러오는 중 네트워크 오류가 발생했습니다.');
                noticeTableBody.innerHTML = '<tr><td colspan="9" class="error-row">네트워크 오류로 정보를 불러오지 못했습니다.</td></tr>';
            }
        }

        // 공지사항 테이블 렌더링 (이전과 동일)
        function renderNoticeTable(notices) {
            noticeTableBody.innerHTML = '';
            if (notices.length === 0) {
                noNoticesMessage.classList.remove('hidden');
                return;
            }
            noNoticesMessage.classList.add('hidden');

            notices.forEach(notice => {
                const row = noticeTableBody.insertRow();
                const displayCreatedAt = notice.created_at ? new Date(notice.created_at).toLocaleDateString() : '-';
                const displayUpdatedAt = notice.updated_at ? new Date(notice.updated_at).toLocaleDateString() : '-';
                
                // 게시 시작일 및 종료일 표시
                const displayStartDate = notice.start_date ? new Date(notice.start_date).toLocaleDateString('ko-KR', { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' }) : '-';
                const displayEndDate = notice.end_date ? new Date(notice.end_date).toLocaleDateString('ko-KR', { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' }) : '-';

                let visibilityText = notice.is_public ? '공개' : '비공개';
                let visibilityClass = notice.is_public ? 'status-public' : 'status-private';

                // 게시 종료일이 지났고 공개 상태이면 "만료됨"으로 표시
                const now = new Date();
                const endDate = notice.end_date ? new Date(notice.end_date) : null;
                if (notice.is_public && endDate && endDate < now) {
                    visibilityText = '만료됨 (비공개)';
                    visibilityClass = 'status-expired';
                }

                row.innerHTML = `
                    <td>${notice.id}</td>
                    <td>${notice.title}</td>
                    <td>${notice.author_nickname || notice.author_username || '-'}</td>
                    <td class="${visibilityClass}">${visibilityText}</td>
                    <td>${displayCreatedAt}</td>
                    <td>${displayUpdatedAt}</td>
                    <td>${displayStartDate}</td>
                    <td>${displayEndDate}</td>
                    <td class="notice-actions-cell">
                        <button class="button small secondary edit-notice-button" data-notice-id="${notice.id}">수정</button>
                        <button class="button small ${notice.is_public ? 'danger' : 'success'} toggle-visibility-button" data-notice-id="${notice.id}">
                            ${notice.is_public ? '비공개 전환' : '공개 전환'}
                        </button>
                        <button class="button small delete-notice-button" data-notice-id="${notice.id}">삭제</button>
                    </td>
                `;
                // 만료된 공지사항 행에 스타일 적용
                if (visibilityClass === 'status-expired') {
                    row.classList.add('expired-notice-row');
                }
            });

            document.querySelectorAll('.edit-notice-button').forEach(button => {
                button.addEventListener('click', (e) => {
                    const noticeId = e.target.dataset.noticeId;
                    openNoticeModalForEdit(noticeId);
                });
            });

            document.querySelectorAll('.toggle-visibility-button').forEach(button => {
                button.addEventListener('click', (e) => {
                    const noticeId = e.target.dataset.noticeId;
                    toggleNoticeVisibility(noticeId);
                });
            });

            document.querySelectorAll('.delete-notice-button').forEach(button => {
                button.addEventListener('click', (e) => {
                    const noticeId = e.target.dataset.noticeId;
                    deleteNotice(noticeId);
                });
            });
        }

        // 공지사항 추가 모달 열기
        addNoticeButton.addEventListener('click', () => {
            modalTitle.textContent = '새 공지사항 작성';
            noticeForm.reset();
            editingNoticeId = null;
            document.getElementById('noticeIsPublic').checked = true; // 기본값 공개
            if (datePickerInstance) {
                datePickerInstance.clear(); // Flatpickr 값 초기화
            }
            noticeModal.classList.add('visible');
        });

        // 공지사항 수정 모달 열기
        async function openNoticeModalForEdit(noticeId) {
            try {
                const response = await fetchWithAuth(`/api/admin/notices/${noticeId}`);
                if (!response || !response.ok) {
                    const errorData = response ? await response.json() : {};
                    await showAlert(errorData.message || '공지사항 정보를 불러오는 데 실패했습니다.');
                    return;
                }
                const notice = await response.json();

                modalTitle.textContent = '공지사항 수정';
                editingNoticeId = noticeId;
                document.getElementById('noticeId').value = noticeId;
                document.getElementById('noticeTitle').value = notice.title;
                document.getElementById('noticeContent').value = notice.content;
                document.getElementById('noticeIsPublic').checked = notice.is_public;
                
                // Flatpickr에 날짜 범위 설정
                let datesToSet = [];
                if (notice.start_date) {
                    datesToSet.push(new Date(notice.start_date));
                }
                if (notice.end_date) {
                    datesToSet.push(new Date(notice.end_date));
                }
                // Flatpickr 인스턴스가 존재하고, 날짜가 있다면 설정
                if (datePickerInstance) {
                    datePickerInstance.setDate(datesToSet, true); // true는 input 값도 업데이트
                } else {
                    // 비상용: Flatpickr가 아직 초기화되지 않았다면, input value만 설정
                    // 이 블록은 initializeFlatpickr가 DOMContentLoaded에서 호출되면 실행되지 않아야 함.
                    if (datesToSet.length === 2) {
                        noticePublishDateRangeInput.value = `${datesToSet[0].toISOString().slice(0, 16)} to ${datesToSet[1].toISOString().slice(0, 16)}`;
                    } else if (datesToSet.length === 1) {
                        noticePublishDateRangeInput.value = datesToSet[0].toISOString().slice(0, 16);
                    } else {
                        noticePublishDateRangeInput.value = '';
                    }
                }

                noticeModal.classList.add('visible');
            } catch (error) {
                console.error('공지사항 정보 로드 중 오류 발생:', error);
                await showAlert('공지사항 정보를 불러오는 중 네트워크 오류가 발생했습니다.');
            }
        }

        // 공지사항 모달 닫기 (취소 버튼 및 X 버튼)
        function closeNoticeModal() {
            noticeModal.classList.remove('visible');
            if (datePickerInstance) {
                datePickerInstance.clear(); // Flatpickr 값 초기화
            }
        }
        cancelNoticeModalButton.addEventListener('click', closeNoticeModal);
        closeModalXButton.addEventListener('click', closeNoticeModal);

        // 공지사항 저장 (추가/수정)
        noticeForm.addEventListener('submit', async (e) => {
            e.preventDefault();

            // Flatpickr에서 선택된 날짜 가져오기
            const selectedDates = datePickerInstance ? datePickerInstance.selectedDates : [];
            let startDate = null;
            let endDate = null;

            if (selectedDates.length === 1) {
                startDate = selectedDates[0];
            } else if (selectedDates.length === 2) {
                startDate = selectedDates[0];
                endDate = selectedDates[1];
            }
            
            const noticeData = {
                title: document.getElementById('noticeTitle').value,
                content: document.getElementById('noticeContent').value,
                is_public: document.getElementById('noticeIsPublic').checked,
                start_date: startDate ? startDate.toISOString() : null, // ISO 문자열로 전송
                end_date: endDate ? endDate.toISOString() : null        // ISO 문자열로 전송
            };

            // 시작일과 종료일 유효성 검사 (선택 사항)
            if (startDate && endDate && endDate < startDate) {
                await showAlert('게시 종료일은 게시 시작일보다 빠를 수 없습니다.');
                return;
            }

            let response;
            let result;

            try {
                if (editingNoticeId) { // 수정
                    response = await fetchWithAuth(`/api/admin/notices/${editingNoticeId}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(noticeData)
                    });
                } else { // 추가
                    response = await fetchWithAuth('/api/admin/notices', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(noticeData)
                    });
                }

                result = await response.json();

                if (response.ok) {
                    await showAlert(result.message || '공지사항이 성공적으로 저장되었습니다.');
                    closeNoticeModal();
                    fetchAllNotices(); // 목록 새로고침
                } else {
                    await showAlert(result.message || '공지사항 저장에 실패했습니다.');
                }
            } catch (error) {
                console.error('공지사항 저장 중 오류 발생:', error);
                await showAlert('공지사항 저장 중 오류가 발생했습니다.');
            }
        });

        // 공지사항 공개/비공개 전환 (이전과 동일)
        async function toggleNoticeVisibility(noticeId) {
            const confirmed = await showConfirm('공지사항의 공개 상태를 전환하시겠습니까?');
            if (!confirmed) {
                return;
            }
            try {
                const response = await fetchWithAuth(`/api/admin/notices/${noticeId}/toggle_visibility`, {
                    method: 'PUT'
                });
                if (response.ok) {
                    const result = await response.json();
                    await showAlert(result.message);
                    fetchAllNotices(); // 목록 새로고침
                } else {
                    await showAlert('공지사항 공개/비공개 전환에 실패했습니다.');
                }
            } catch (error) {
                console.error('공지사항 공개/비공개 전환 중 오류 발생:', error);
                await showAlert('공지사항 공개/비공개 전환 중 오류가 발생했습니다.');
            }
        }

        // 공지사항 삭제 함수 (이전과 동일)
        async function deleteNotice(noticeId) {
            const confirmed = await showConfirm('정말로 이 공지사항을 삭제하시겠습니까?');
            if (!confirmed) {
                return;
            }
            try {
                const response = await fetchWithAuth(`/api/admin/notices/${noticeId}`, {
                    method: 'DELETE'
                });
                if (response.ok) {
                    const result = await response.json();
                    await showAlert(result.message || '공지사항이 성공적으로 삭제되었습니다.');
                    fetchAllNotices(); // 목록 새로고침
                } else {
                    const errorData = await response.json();
                    await showAlert(errorData.message || '공지사항 삭제에 실패했습니다.');
                }
            } catch (error) {
                console.error('공지사항 삭제 중 오류 발생:', error);
                await showAlert('공지사항 삭제 중 네트워크 오류가 발생했습니다.');
            }
        }

        // 초기 로드 시 관리자/운영자 접근 권한 확인 후 데이터 로드 및 Flatpickr 초기화
        document.addEventListener('DOMContentLoaded', async () => {
            const hasAccess = await checkAdminOrOperatorAccess();
            if (hasAccess) {
                fetchAllNotices();
                initializeFlatpickr(); // 페이지 로드 시 Flatpickr 한 번만 초기화
            }
        });
    </script>
{% endblock %}
